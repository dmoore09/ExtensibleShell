CS3214 Spring 2014 Project 1 - “Extensible Shell”

1 Introduction

  This assignment introduces you to the principles of process management and job control
in a Unix-like operating system. In addition, the assignment will give you insights into
the design and use of extensible systems.
This is an open-ended assignment. In addition to implementing the required functionality,
we encourage you to define the scope of this project yourself.

2 Base Functionality

  A shell receives line-by-line input from a terminal. If the user inputs a built-in command,
the shell will execute this command. Otherwise, the shell will interpret the input as the
name of a program to be executed, along with arguments to be passed to it. In this case,
the shell will fork a new child process and execute the program in the context of the child.
Normally, the shell will wait for a command to complete before reading the next command
from the user. If the user appends an ampersand ‘&’ to a command, the command
is started in the background and the shell will return to the prompt immediately.
The shell provides job control. A user may interrupt foreground jobs, send foreground jobs
into the background, and vice versa. At a given point in time, a shell may run zero or more
background jobs and zero or one foreground jobs. If there is a foreground job, the shell
waits for it to complete before printing another prompt and reading the next command.
In addition, the shell informs the user about status changes of the jobs it manages. For
instance, jobs may exit, or terminate due to a signal, or be stopped for several reasons.
At a minimum, we expect that your shell has the ability to start foreground and background
jobs and implements the built-in commands ‘jobs,’ ‘fg,’ ‘bg,’ ‘kill,’ and ‘stop.’ The
semantics of these commands should match the semantics of the same-named commands
in bash or tcsh. The ability to correctly respond to ˆC (SIGINT) and ˆZ (SIGTSTP) is expected,
as are informative messages about the status of the children managed. Like bash
or tcsh, you should use consecutively numbered small integers to enumerate your jobs.
For the minimum functionality, the shell need not support pipes (|), I/O redirection
(< > >>), nor the ability to run programs that require exclusive access to the terminal
(e.g., vim).
Created by G. Back (gback@cs.vt.edu) 1 Revision : 1:10 January 16, 2014
CS3214 Spring 2014 Project 1 - “Extensible Shell”
We expect most students to implement pipes, I/O redirection, and managing the controlling
terminal to ensure that jobs that require exclusive access to the terminal obtain such
access. Beyond that, esh’s extensibility, described in Section 6 should allow for plenty of
creative freedom.

3 Strategy

  You will need to use fork(), a variant of exec*(), and the waitpid() system calls.

3.1 Signal Handling

  You will need to catch SIGCHLD to learn about when the shell’s child processes change
status. Since child processes execute concurrently with respect to the parent shell, it is
impossible to predict when a child will exit (or terminate with a signal), and thus it is
impossible to predict when this signal will arrive. In the worst case, a child may have
terminated by the time the parent() returns from fork()!
You will need to block the signal in those sections of your code where you access data
structures that are also needed by the handler that is executed when this signal arrives.
For example, consider the data structure used to maintain the current set of jobs. A new
job is added after a child process has been forked; a job may be removed when SIGCHLD
is received. To avoid a situation where the job has not yet been added when SIGCHLD
arrives, or - worse - a situation in which SIGCHLD arrives while the shell is adding the
job, the parent should block SIGCHLD until after it completed adding the job to the list.
If the SIGCHLD is delivered to the shell while the shell blocks this signal, it is marked
pending and will be received as soon as the shell unblocks this signal.
Use sigprocmask(2) to block and unblock signals. To set up signal handlers, use the sigaction(
2) system call. Set sa flags to SA RESTART. The mask of blocked signals is inherited
when fork() is called. Consequently, the child will need to unblock any signals the parent
blocked before calling fork().

3.2 Process Groups

  Each process in Unix is part of a group. Each process group has a leader. To create a new
group with itself as the leader, a process simply calls setpgid(0, 0). The id of a process
group is the process id of the leader. Child processes inherit the process group of their
parent process initially. They can then form their own group if desired, or their parent
process can place them into a different process group via setpgid().
Process groups are treated as an ensemble for the purpose of signal delivery and when
waiting for processes. Specifically, the kill(2), killpg(2), and waitpid(2) system calls sup-
Created by G. Back (gback@cs.vt.edu) 2 Revision : 1:10 January 16, 2014
CS3214 Spring 2014 Project 1 - “Extensible Shell”
port the naming of process groups1. In addition, process groups are used to manage
access to the terminal, as described next.

3.3 Managing Access To The Terminal

  Running multiple processes on the same terminal creates a sharing issue: if multiple processes
attempt to read from the terminal, which process should receive the input? Similarly,
some programs - such as vi - output to the terminal in a way that does not allow
them to share the terminal with others. 2
To solve this problem, Unix introduced the concept of a foreground process group. Each
terminal maintains such a group. If a process in a process group that is not the foreground
process group attempts to perform an operation that would require exclusive access, it is
sent a signal: SIGTTOU or SIGTTIN, depending on whether the use was for output or
input. The default action is to suspend the process. In this case, the parent can learn
about this status change by calling waitpid(). WIFSTOPPED(status) will be true in this
case. To allow this process to continue, its process group must be made the foreground
process group of the controlling terminal via tcsetpgrp(), and then the process must be
sent a SIGCONT signal. The state of the terminal must be saved when the process was
suspended and restored when it is continued.
Signals that are sent as a result of user input, such as SIGINT or SIGTSTP, are also sent to
a terminal’s foreground process group.

3.4 Pipes and I/O Redirection

  To implement pipes, use the pipe(2) system call. A pipe must be set up by the parent
shell process before a child is forked. Forking a child will inherit the file descriptors that
are part of the pipe(). The child must then redirect its stdout/stdin file descriptor to the
pipe’s input or output end as needed using the dup2(2) system call.
Note that all processes that are part of a pipeline are children of the shell, e.g., if a user
runs a | b then the process executing b is not a child process of the process executing
the program a.
Generally, a pipeline of commands is considered one job. All processes that form part of
a pipeline should thus be part of the same process group.
Although the parent shell process creates the pipe, it will not actually write to it or read
from it. Make sure that the parent shell process closes the file descriptors referring to
the pipe after the child was forked in order to avoid leaking file descriptors, as well as
1Note the idiosynchracies of the API: kill(-pid, sig) does the same as killpg(pid, sig). Make sure to use
the correct call.
2Note that regular output via write(2) does not require exclusive access, unless the terminal’s ’tostop’
flag is set.
Created by G. Back (gback@cs.vt.edu) 3 Revision : 1:10 January 16, 2014
CS3214 Spring 2014 Project 1 - “Extensible Shell”
to guarantee the correct functioning of programs that rely on taking action when their
standard input stream reaches end of file. Closing a file descriptor affects only the current
process’s access to the underlying object. When the parent shell closes the file descriptor
referring to the pipe it created, the child processes will still be able to access the pipe’s
ends. This is true for file descriptors in general. Each file descriptor represents a reference
to an underlying kernel object. The actual object (such as a pipe or file) is closed only
when the last process who has a file descriptor referring to the object closes it. Note that
when a process exits for whatever reason, including a signal, all file descriptors it had
open are closed by the kernel.
Additional information can be found in the GNU C library manual, available at http://
www.gnu.org/s/libc/manual/html_node/index.html. Read, in particular, the
sections on Signal Handling and Job Control.

4 Use of SVN

  You must use SVN for this project. SVN is a widely used source code version control
system, which allows multiple developers to share a code base. You will use the SVN
repository located at https://cvs.cs.vt.edu/cs3214/spring14. We will create a project directory
with appropriate permissions for you. To start, we will use the group information
you have provided in the grouper interface, which will display your group number.
For instance, if you are group4, the SVN project directory would be located at
https://cvs.cs.vt.edu/cs3214/spring14/group4.
The provided code is in the directory~cs3214/esh-20140116. One team member, and one
team member only, should import this directory and check out a working copy using the
following commands
cd ˜cs3214/esh-20140116
svn import . https://cvs.cs.vt.edu/cs3214/spring14/<your group id> \
--message "Initial import"
cd <into a read-protected directory of your choice>
svn co https://cvs.cs.vt.edu/cs3214/spring14/<your group id>
The second team member will issue only the checkout (svn co) command in a directory of
their choice. If updates or bug fixes to this code are required, they will be announced on
the forum. You will be required to use a SVN repository even if you work by yourselves.
We will give teaching staff read permissions to your repository and assign a portion of
the project credit for making proper use of this version control facility, which includes
continous checkins of intermediate milestones.
SVN uses a ’copy-modify-merge’ model in which multiple developers (e.g., both team
members) make a copy of the code in the repository, independently modify their copy,
then commit their changes. If the changes conflict (that is, if both made changes to the
same lines in the code), the second committer must merge the changes and resolve any
conflicts.
Created by G. Back (gback@cs.vt.edu) 4 Revision : 1:10 January 16, 2014
CS3214 Spring 2014 Project 1 - “Extensible Shell”

4.1 Code Base

The code contains a command line parser that implements the following grammar:
cmd_line : cmd_list
cmd_list :
| pipeline
| cmd_list ’;’
| cmd_list ’&’
| cmd_list ’;’ pipeline
| cmd_list ’&’ pipeline
pipeline : command
| pipeline ’|’ command
command : WORD
| input
| output
| command WORD
| command input
| command output
input : ’<’ WORD
output : ’>’ WORD
| ’>>’ WORD
Look at the provided esh.c main function to see how to invoke the parser. If a command
line is semantically correct, the parser code will create a esh command line data
structure, which refers to a list of esh pipeline structures. Each esh pipeline corresponds
to a job. It may consist of one or more individual commands that form a pipeline.
Each command is represented as a esh command structure. Study the definitions of these
structures.
By default, the provided code will read a line, parse it, and dump the parsed command
line to stdout.
The file esh-sys-utils.c contains a number of utility functions for dealing with ttys
and signals. We strongly recommend you use these functions rather than directly calling
the functions described in the textbook.

5 Testing

  We will provide a test driver to test your project, and tests for the basic functionality. You
must provide additional tests for the advanced functionality to receive credit for implementing
it. These tests will be checked to verify that they sufficiently test the functionality
Created by G. Back (gback@cs.vt.edu) 5 Revision : 1:10 January 16, 2014
CS3214 Spring 2014 Project 1 - “Extensible Shell”
in question. Please follow the form of the basic tests when implementing the advanced
tests, which can be viewed at
˜cs3214/public_html/spring2014/projects/eshtests/basic/

6 Plug-Ins

  It is often impossible to anticipate the future uses and needs of a system or application.
Extensible architectures address this problem by allowing the loading of plug-ins that
provide additional functionality or enhance built-in functionality.
When started with the ’-p dir’ flag, ’esh’ will dynamically load shared libraries contained
in the directory ’dir.’ Multiple -p flags may be provided. Each shared library must define
a strong global symbol named esh module, which shall refer to an instance of struct
esh plugin. This struct contains information about the plug-in, including a set of function
pointers to invoke the plug-in’s functionality.
Multiple plug-ins may be loaded; a plug-in may specify its rank relative to others. Your
shell should invoke the plug-ins’ functions in increasing rank order. If plug-ins share
the same rank, their execution order is not defined. Some functionality (e.g., built-ins)
requires that invocation stop if a plug-in provides this functionality.
Here are some ideas for plug-ins:
 Change current directory (cd)
 Glob expansion (e.g., *.c)
 Setting and unsetting environment variables
 Timing commands: ”time” or time-outs.
 Aliases
 Shell variables
 pushd, popd, etc.
 Command-line history (perhaps using’s GNU History library)
 Backquote substitution
 Smart command-line completion
 Embedding applications: scripting languages, web servers, etc.
A side-note on Unix philosophy - in general, Unix implements functionality using many
small programs and utilities. As such, built-in commands are often only those that must
be implemented within the shell, such as cd. In addition, essential commands such as
’kill’ are often built-in to make sure an operator can execute those commands even if no
new processes can be forked. Your plug-ins should generally stay with this philosophy
Created by G. Back (gback@cs.vt.edu) 6 Revision : 1:10 January 16, 2014
CS3214 Spring 2014 Project 1 - “Extensible Shell”
and implement only functionality that is not already available using Unix commands or
that would be better implemented using separate programs. If in doubt, ask.
You will note that the functions to read from the terminal and to parse the command
line are invoked indirectly as function pointers that are part of esh shell. Advanced
plug-ins may replace those if desired.
